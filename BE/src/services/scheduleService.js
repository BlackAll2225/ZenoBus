const Schedule = require('../models/ScheduleSequelizeModel');
const Bus = require('../models/BusModel');
const Route = require('../models/RouteModel');
const Driver = require('../models/DriverModel');
const BusType = require('../models/BusTypeModel');
const Province = require('../models/provinceModel');
const SchedulePattern = require('../models/SchedulePatternModel');
const { Op } = require('sequelize');
const sequelize = require('../config/database');

const scheduleService = {
  // Lấy danh sách lịch trình với filtering và pagination
  async getSchedules(filters = {}, pagination = { page: 1, limit: 20 }) {
    try {
      // Build where clause
      const whereClause = {};
      
      if (filters.routeId) {
        whereClause.routeId = filters.routeId;
      }
      
      if (filters.busId) {
        whereClause.busId = filters.busId;
      }
      
      if (filters.driverId) {
        whereClause.driverId = filters.driverId;
      }
      
      if (filters.status) {
        whereClause.status = filters.status;
      }
      
      if (filters.isAutoGenerated !== undefined) {
        whereClause.isAutoGenerated = filters.isAutoGenerated;
      }
      
      if (filters.patternId) {
        whereClause.patternId = filters.patternId;
      }
      
      if (filters.departureDate) {
        // Convert VN date range to UTC for database query
        const startOfDay = new Date(filters.departureDate);
        const endOfDay = new Date(filters.departureDate);
        endOfDay.setHours(23, 59, 59, 999);
        
        whereClause.departureTime = {
          [Op.between]: [
            new Date(startOfDay.getTime() - (7 * 60 * 60 * 1000)), // Convert VN to UTC
            new Date(endOfDay.getTime() - (7 * 60 * 60 * 1000))    // Convert VN to UTC
          ]
        };
      }
      
      if (filters.startDate && filters.endDate) {
        // Convert VN date range to UTC for database query
        const startDate = new Date(filters.startDate);
        const endDate = new Date(filters.endDate);
        
        whereClause.departureTime = {
          [Op.between]: [
            new Date(startDate.getTime() - (7 * 60 * 60 * 1000)), // Convert VN to UTC
            new Date(endDate.getTime() - (7 * 60 * 60 * 1000))    // Convert VN to UTC
          ]
        };
      }
      
      // Search functionality
      let searchWhere = {};
      if (filters.search) {
        searchWhere = {
          [Op.or]: [
            { '$route.departureProvince.name$': { [Op.like]: `%${filters.search}%` } },
            { '$route.arrivalProvince.name$': { [Op.like]: `%${filters.search}%` } },
            { '$bus.licensePlate$': { [Op.like]: `%${filters.search}%` } },
            { '$driver.fullName$': { [Op.like]: `%${filters.search}%` } }
          ]
        };
      }
      
      // Count total records
      const total = await Schedule.count({
        where: { ...whereClause, ...searchWhere },
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: Bus,
            as: 'bus',
            include: [{ model: BusType, as: 'busType' }]
          },
          {
            model: Driver,
            as: 'driver'
          },
          {
            model: SchedulePattern,
            as: 'pattern'
          }
        ]
      });
      
      // Calculate pagination
      const offset = (pagination.page - 1) * pagination.limit;
      const totalPages = Math.ceil(total / pagination.limit);
      
      // Get schedules with pagination
      const schedules = await Schedule.findAll({
        where: { ...whereClause, ...searchWhere },
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: Bus,
            as: 'bus',
            include: [{ model: BusType, as: 'busType' }]
          },
          {
            model: Driver,
            as: 'driver'
          },
          {
            model: SchedulePattern,
            as: 'pattern'
          }
        ],
        order: [['departureTime', 'DESC']],
        limit: pagination.limit,
        offset: offset
      });
      
      // Transform data to match expected format
      const transformedSchedules = schedules.map(schedule => ({
        id: schedule.id,
        busId: schedule.busId,
        routeId: schedule.routeId,
        driverId: schedule.driverId,
        departureTime: schedule.departureTime,
        actualDepartureTime: schedule.actualDepartureTime,
        actualArrivalTime: schedule.actualArrivalTime,
        price: schedule.price,
        status: schedule.status,
        isAutoGenerated: schedule.isAutoGenerated,
        patternId: schedule.patternId,
        createdAt: schedule.createdAt,
        bus: schedule.bus ? {
          id: schedule.bus.id,
          licensePlate: schedule.bus.licensePlate,
          seatCount: schedule.bus.seatCount,
          description: schedule.bus.description,
          busType: schedule.bus.busType ? {
            name: schedule.bus.busType.name
          } : null
        } : null,
        route: schedule.route ? {
          id: schedule.route.id,
          departureProvince: schedule.route.departureProvince ? schedule.route.departureProvince.name : null,
          arrivalProvince: schedule.route.arrivalProvince ? schedule.route.arrivalProvince.name : null,
          distanceKm: schedule.route.distanceKm,
          estimatedTime: schedule.route.estimatedTime
        } : null,
        driver: schedule.driver ? {
          id: schedule.driver.id,
          fullName: schedule.driver.fullName,
          phoneNumber: schedule.driver.phoneNumber,
          licenseNumber: schedule.driver.licenseNumber
        } : null,
        pattern: schedule.pattern ? {
          id: schedule.pattern.id,
          name: schedule.pattern.name
        } : null
      }));
      
      return {
        data: transformedSchedules,
        pagination: {
          page: pagination.page,
          limit: pagination.limit,
          total: total,
          totalPages: totalPages
        }
      };
    } catch (error) {
      console.error('Error in getSchedules:', error);
      throw new Error('Không thể lấy danh sách lịch trình');
    }
  },

  // Lấy thông tin lịch trình theo ID
  async getScheduleById(id) {
    try {
      const schedule = await Schedule.findByPk(id, {
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: Bus,
            as: 'bus',
            include: [{ model: BusType, as: 'busType' }]
          },
          {
            model: Driver,
            as: 'driver'
          },
          {
            model: SchedulePattern,
            as: 'pattern'
          }
        ]
      });
      
      if (!schedule) {
        return null;
      }
      
      return {
        id: schedule.id,
        busId: schedule.busId,
        routeId: schedule.routeId,
        driverId: schedule.driverId,
        departureTime: schedule.departureTime,
        actualDepartureTime: schedule.actualDepartureTime,
        actualArrivalTime: schedule.actualArrivalTime,
        price: schedule.price,
        status: schedule.status,
        isAutoGenerated: schedule.isAutoGenerated,
        patternId: schedule.patternId,
        createdAt: schedule.createdAt,
        bus: schedule.bus ? {
          id: schedule.bus.id,
          licensePlate: schedule.bus.licensePlate,
          seatCount: schedule.bus.seatCount,
          description: schedule.bus.description,
          busType: schedule.bus.busType ? {
            name: schedule.bus.busType.name
          } : null
        } : null,
        route: schedule.route ? {
          id: schedule.route.id,
          departureProvince: schedule.route.departureProvince ? schedule.route.departureProvince.name : null,
          arrivalProvince: schedule.route.arrivalProvince ? schedule.route.arrivalProvince.name : null,
          distanceKm: schedule.route.distanceKm,
          estimatedTime: schedule.route.estimatedTime
        } : null,
        driver: schedule.driver ? {
          id: schedule.driver.id,
          fullName: schedule.driver.fullName,
          phoneNumber: schedule.driver.phoneNumber,
          licenseNumber: schedule.driver.licenseNumber
        } : null,
        pattern: schedule.pattern ? {
          id: schedule.pattern.id,
          name: schedule.pattern.name
        } : null
      };
    } catch (error) {
      console.error('Error in getScheduleById:', error);
      throw new Error('Không thể lấy thông tin lịch trình');
    }
  },

  // Tạo lịch trình mới
  async createSchedule(scheduleData) {
    try {
      // Validate foreign keys
      await this.validateScheduleData(scheduleData);
      
      // Convert departureTime to proper Date object
      let departureTime = scheduleData.departureTime;
      console.log('Original departureTime:', departureTime, typeof departureTime);
      
      if (typeof departureTime === 'string') {
        // Parse ISO format (2025-07-31T08:00:00) to Date in UTC
        try {
          // Extract date and time parts
          const match = departureTime.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/);
          if (match) {
            const [, year, month, day, hour, minute, second] = match;
            // Create date in UTC timezone - subtract 7 hours from local VN time
            departureTime = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour) - 7, parseInt(minute), parseInt(second)));
          } else {
            // Try to parse as ISO string, if no timezone assume VN time and convert to UTC
            const tempDate = new Date(departureTime);
            if (!departureTime.includes('Z') && !departureTime.includes('+') && !departureTime.includes('-', 10)) {
              // No timezone info, assume VN time (UTC+7) and convert to UTC
              departureTime = new Date(tempDate.getTime() - (7 * 60 * 60 * 1000));
            } else {
              departureTime = tempDate;
            }
          }
        } catch (error) {
          console.error('Error parsing date:', error);
          throw new Error('Thời gian khởi hành không hợp lệ');
        }
      }
      
      console.log('Converted departureTime:', departureTime);
      
      // Validate date
      if (isNaN(departureTime.getTime())) {
        throw new Error('Thời gian khởi hành không hợp lệ');
      }
      
      // Format for SQL Server - YYYY-MM-DD HH:mm:ss
      const year = departureTime.getFullYear();
      const month = String(departureTime.getMonth() + 1).padStart(2, '0');
      const day = String(departureTime.getDate()).padStart(2, '0');
      const hours = String(departureTime.getHours()).padStart(2, '0');
      const minutes = String(departureTime.getMinutes()).padStart(2, '0');
      const seconds = String(departureTime.getSeconds()).padStart(2, '0');
      
      const sqlServerDateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      console.log('SQL Server formatted:', sqlServerDateTime);
      
      // Use raw SQL with proper datetime format
      const [result] = await sequelize.query(`
        INSERT INTO schedules (bus_id, route_id, driver_id, departure_time, price, status, pattern_id, is_auto_generated, created_at)
        VALUES (?, ?, ?, CONVERT(DATETIME, ?), ?, ?, ?, ?, GETDATE());
        SELECT SCOPE_IDENTITY() as id;
      `, {
        replacements: [
          scheduleData.busId,
          scheduleData.routeId,
          scheduleData.driverId,
          sqlServerDateTime,
          scheduleData.price,
          scheduleData.status || 'scheduled',
          scheduleData.patternId || null,
          scheduleData.patternId ? 1 : 0
        ],
        type: sequelize.QueryTypes.INSERT
      });
      
      // Get the created schedule
      const scheduleId = result[0].id;
      const schedule = await Schedule.findByPk(scheduleId);
      
      // Create seats for the schedule
      await this.createSeatsForSchedule(scheduleId, scheduleData.busId);
      
      // Return the created schedule
      return await this.getScheduleById(scheduleId);
    } catch (error) {
      console.error('Error in createSchedule:', error);
      throw error;
    }
  },

  // Tạo nhiều lịch trình từ pattern
  async bulkCreateSchedules(bulkData) {
    try {
      // Get pattern information
      const pattern = await SchedulePattern.findByPk(bulkData.patternId, {
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: BusType,
            as: 'busType'
          }
        ]
      });
      
      if (!pattern || !pattern.isActive) {
        throw new Error('Pattern không tồn tại hoặc không hoạt động');
      }
      
      // Parse departure times and days of week
      const departureTimes = JSON.parse(pattern.departureTimes);
      const daysOfWeek = pattern.daysOfWeek.split(',').map(d => parseInt(d.trim()));
      
      // Generate dates between start and end date
      const startDate = new Date(bulkData.startDate);
      const endDate = new Date(bulkData.endDate);
      const dates = [];
      
      for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
        const dayOfWeek = d.getDay() === 0 ? 7 : d.getDay(); // Convert Sunday from 0 to 7
        if (daysOfWeek.includes(dayOfWeek)) {
          dates.push(new Date(d));
        }
      }
      
      // Auto-assign bus and driver if not provided
      let assignedBusId = bulkData.busId;
      let assignedDriverId = bulkData.driverId;
      
      if (!assignedBusId) {
        // Find available bus for the route
        const bus = await Bus.findOne({
          where: { 
            isActive: true,
            busTypeId: pattern.busTypeId
          }
        });
        
        if (!bus) {
          throw new Error('Không tìm thấy xe bus phù hợp');
        }
        assignedBusId = bus.id;
      }
      
      if (!assignedDriverId) {
        // Find available driver
        const driver = await Driver.findOne({
          where: { isActive: true }
        });
        
        if (!driver) {
          throw new Error('Không tìm thấy tài xế phù hợp');
        }
        assignedDriverId = driver.id;
      }
      
      // Create schedules
      const createdSchedules = [];
      const price = bulkData.priceOverride || pattern.basePrice;
      
      for (const date of dates) {
        for (const time of departureTimes) {
          const [hours, minutes] = time.split(':').map(Number);
          const departureTime = new Date(date);
          // Set hours in VN time, then convert to UTC
          departureTime.setHours(hours, minutes, 0, 0);
          // Convert VN time to UTC by subtracting 7 hours
          const utcDepartureTime = new Date(departureTime.getTime() - (7 * 60 * 60 * 1000));
          
          const scheduleData = {
            busId: assignedBusId,
            routeId: pattern.routeId,
            driverId: assignedDriverId,
            departureTime: utcDepartureTime,
            price: price,
            status: 'scheduled',
            patternId: pattern.id
          };
          
          const schedule = await this.createSchedule(scheduleData);
          createdSchedules.push(schedule);
        }
      }
      
      return {
        created: createdSchedules.length,
        schedules: createdSchedules,
        summary: {
          patternName: pattern.name,
          dateRange: `${bulkData.startDate} - ${bulkData.endDate}`,
          totalDays: dates.length,
          schedulesPerDay: departureTimes.length
        }
      };
    } catch (error) {
      console.error('Error in bulkCreateSchedules:', error);
      throw error;
    }
  },

  // Cập nhật lịch trình
  async updateSchedule(id, updateData) {
    try {
      // Check if schedule exists
      const existingSchedule = await Schedule.findByPk(id);
      if (!existingSchedule) {
        return null;
      }

      // Check if schedule has bookings
      const { sql, poolPromise } = require('../config/db');
      const pool = await poolPromise;
      const bookingResult = await pool.request()
        .input('scheduleId', sql.Int, id)
        .query('SELECT COUNT(*) as count FROM bookings WHERE schedule_id = @scheduleId');
      
      const bookingCount = bookingResult.recordset[0].count;
      if (bookingCount > 0) {
        const error = new Error('Không thể sửa lịch trình đã có khách đặt');
        error.statusCode = 400;
        throw error;
      }
      
      // Validate foreign keys if provided
      if (updateData.busId || updateData.routeId || updateData.driverId) {
        await this.validateScheduleData(updateData);
      }
      
      // Process departureTime if provided
      if (updateData.departureTime) {
        // Parse the datetime similar to createSchedule
        let departureTime = updateData.departureTime;
        console.log('Original departureTime for update:', departureTime, typeof departureTime);
        
        if (typeof departureTime === 'string') {
          try {
            // Extract date and time parts
            const match = departureTime.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})/);
            if (match) {
              const [, year, month, day, hour, minute, second] = match;
              // Create date in UTC timezone
              departureTime = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
            } else {
              // Try direct parsing
              departureTime = new Date(departureTime);
            }
          } catch (error) {
            console.error('Error parsing update date:', error);
            throw new Error('Thời gian khởi hành không hợp lệ');
          }
        }
        
        console.log('Converted departureTime for update:', departureTime);
        updateData.departureTime = departureTime;
      }
      
      // Update schedule using raw SQL if departureTime is involved
      if (updateData.departureTime) {
        const { sql, poolPromise } = require('../config/db');
        const pool = await poolPromise;
        
        // Build dynamic update query
        const setParts = [];
        const request = pool.request();
        let paramIndex = 1;
        
        if (updateData.busId) {
          setParts.push(`bus_id = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Int, updateData.busId);
          paramIndex++;
        }
        
        if (updateData.routeId) {
          setParts.push(`route_id = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Int, updateData.routeId);
          paramIndex++;
        }
        
        if (updateData.driverId) {
          setParts.push(`driver_id = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Int, updateData.driverId);
          paramIndex++;
        }
        
        if (updateData.price) {
          setParts.push(`price = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Decimal(10, 2), updateData.price);
          paramIndex++;
        }
        
        if (updateData.status) {
          setParts.push(`status = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.VarChar(50), updateData.status);
          paramIndex++;
        }
        
        if (updateData.departureTime) {
          setParts.push(`departure_time = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.DateTime, updateData.departureTime);
          paramIndex++;
        }
        
        if (setParts.length > 0) {
          const query = `UPDATE schedules SET ${setParts.join(', ')} WHERE id = @scheduleId`;
          request.input('scheduleId', sql.Int, id);
          
          console.log('Raw SQL update query:', query);
          await request.query(query);
        }
      } else {
        // Use Sequelize for non-datetime updates
        await existingSchedule.update(updateData);
      }
      
      return await this.getScheduleById(id);
    } catch (error) {
      console.error('Error in updateSchedule:', error);
      throw error;
    }
  },

  // Xóa lịch trình
  async deleteSchedule(id) {
    try {
      // Check if schedule has bookings
      const bookingCount = await require('../models/BookingModel').count({
        where: { scheduleId: id }
      });
      
      if (bookingCount > 0) {
        throw new Error('Không thể xóa lịch trình có booking');
      }
      
      // Delete seats first
      await require('../models/SeatModel').destroy({
        where: { scheduleId: id }
      });
      
      // Delete schedule
      const result = await Schedule.destroy({
        where: { id: id }
      });
      
      return result > 0;
    } catch (error) {
      console.error('Error in deleteSchedule:', error);
      throw error;
    }
  },

  // Helper: Validate schedule data
  async validateScheduleData(scheduleData) {
    if (scheduleData.busId) {
      const bus = await Bus.findByPk(scheduleData.busId);
      if (!bus ) {
        throw new Error('Xe bus không tồn tại hoặc không hoạt động');
      }
    }
    
    if (scheduleData.routeId) {
      const route = await Route.findByPk(scheduleData.routeId);
      if (!route) {
        throw new Error('Tuyến đường không tồn tại');
      }
    }
    
    if (scheduleData.driverId) {
      const driver = await Driver.findByPk(scheduleData.driverId);
      if (!driver || !driver.isActive) {
        throw new Error('Tài xế không tồn tại hoặc không hoạt động');
      }
    }
  },

  // Helper: Create seats for schedule
  async createSeatsForSchedule(scheduleId, busId) {
    const bus = await Bus.findByPk(busId);
    if (!bus) {
      throw new Error('Xe bus không tồn tại');
    }
    
    const seatCount = bus.seatCount;
    const Seat = require('../models/SeatModel');
    
    // Create seats
    const seatData = [];
    for (let i = 1; i <= seatCount; i++) {
      const seatNumber = i.toString().padStart(2, '0');
      const floor = i <= 20 ? 'lower' : 'upper'; // Assume first 20 seats are lower floor
      
      seatData.push({
        scheduleId: scheduleId,
        seatNumber: seatNumber,
        status: 'available',
        floor: floor,
        isEnabled: true
      });
    }
    
    await Seat.bulkCreate(seatData);
  }
};

module.exports = scheduleService; 