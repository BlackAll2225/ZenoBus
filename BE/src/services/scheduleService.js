const Schedule = require('../models/ScheduleSequelizeModel');
const Bus = require('../models/BusModel');
const Route = require('../models/RouteModel');
const Driver = require('../models/DriverModel');
const BusType = require('../models/BusTypeModel');
const Province = require('../models/provinceModel');
const SchedulePattern = require('../models/SchedulePatternModel');
const { Op } = require('sequelize');
const sequelize = require('../config/database');

const scheduleService = {
  // Lấy danh sách lịch trình với filtering và pagination
  async getSchedules(filters = {}, pagination = { page: 1, limit: 20 }) {
    try {
      // Build where clause
      const whereClause = {};
      
      if (filters.routeId) {
        whereClause.routeId = filters.routeId;
      }
      
      if (filters.busId) {
        whereClause.busId = filters.busId;
      }
      
      if (filters.driverId) {
        whereClause.driverId = filters.driverId;
      }
      
      if (filters.status) {
        whereClause.status = filters.status;
      }
      
      if (filters.isAutoGenerated !== undefined) {
        whereClause.isAutoGenerated = filters.isAutoGenerated;
      }
      
      if (filters.patternId) {
        whereClause.patternId = filters.patternId;
      }
      
      if (filters.departureDate) {
        // Use UTC date range directly (no timezone conversion)
        const startOfDay = new Date(filters.departureDate);
        const endOfDay = new Date(filters.departureDate);
        endOfDay.setHours(23, 59, 59, 999);
        
        whereClause.departureTime = {
          [Op.between]: [
            startOfDay, // Use UTC directly
            endOfDay    // Use UTC directly
          ]
        };
      }
      
      if (filters.startDate && filters.endDate) {
        // Use UTC date range directly (no timezone conversion)
        const startDate = new Date(filters.startDate);
        const endDate = new Date(filters.endDate);
        
        whereClause.departureTime = {
          [Op.between]: [
            startDate, // Use UTC directly
            endDate    // Use UTC directly
          ]
        };
      }
      
      // Search functionality
      let searchWhere = {};
      if (filters.search) {
        searchWhere = {
          [Op.or]: [
            { '$route.departureProvince.name$': { [Op.like]: `%${filters.search}%` } },
            { '$route.arrivalProvince.name$': { [Op.like]: `%${filters.search}%` } },
            { '$bus.licensePlate$': { [Op.like]: `%${filters.search}%` } },
            { '$driver.fullName$': { [Op.like]: `%${filters.search}%` } }
          ]
        };
      }
      
      // Count total records
      const total = await Schedule.count({
        where: { ...whereClause, ...searchWhere },
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: Bus,
            as: 'bus',
            include: [{ model: BusType, as: 'busType' }]
          },
          {
            model: Driver,
            as: 'driver'
          },
          {
            model: SchedulePattern,
            as: 'pattern'
          }
        ]
      });
      
      // Calculate pagination
      const offset = (pagination.page - 1) * pagination.limit;
      const totalPages = Math.ceil(total / pagination.limit);
      
      // Get schedules with pagination
      const schedules = await Schedule.findAll({
        where: { ...whereClause, ...searchWhere },
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: Bus,
            as: 'bus',
            include: [{ model: BusType, as: 'busType' }]
          },
          {
            model: Driver,
            as: 'driver'
          },
          {
            model: SchedulePattern,
            as: 'pattern'
          }
        ],
        order: [['departureTime', 'DESC']],
        limit: pagination.limit,
        offset: offset
      });
      
      // Transform data to match expected format
      const transformedSchedules = schedules.map(schedule => ({
        id: schedule.id,
        busId: schedule.busId,
        routeId: schedule.routeId,
        driverId: schedule.driverId,
        departureTime: schedule.departureTime,
        actualDepartureTime: schedule.actualDepartureTime,
        actualArrivalTime: schedule.actualArrivalTime,
        price: schedule.price,
        status: schedule.status,
        isAutoGenerated: schedule.isAutoGenerated,
        patternId: schedule.patternId,
        createdAt: schedule.createdAt,
        bus: schedule.bus ? {
          id: schedule.bus.id,
          licensePlate: schedule.bus.licensePlate,
          seatCount: schedule.bus.seatCount,
          description: schedule.bus.description,
          busType: schedule.bus.busType ? {
            name: schedule.bus.busType.name
          } : null
        } : null,
        route: schedule.route ? {
          id: schedule.route.id,
          departureProvince: schedule.route.departureProvince ? schedule.route.departureProvince.name : null,
          arrivalProvince: schedule.route.arrivalProvince ? schedule.route.arrivalProvince.name : null,
          distanceKm: schedule.route.distanceKm,
          estimatedTime: schedule.route.estimatedTime
        } : null,
        driver: schedule.driver ? {
          id: schedule.driver.id,
          fullName: schedule.driver.fullName,
          phoneNumber: schedule.driver.phoneNumber,
          licenseNumber: schedule.driver.licenseNumber
        } : null,
        pattern: schedule.pattern ? {
          id: schedule.pattern.id,
          name: schedule.pattern.name
        } : null
      }));
      
      return {
        data: transformedSchedules,
        pagination: {
          page: pagination.page,
          limit: pagination.limit,
          total: total,
          totalPages: totalPages
        }
      };
    } catch (error) {
      console.error('Error in getSchedules:', error);
      throw new Error('Không thể lấy danh sách lịch trình');
    }
  },

  // Lấy thông tin lịch trình theo ID
  async getScheduleById(id) {
    try {
      const schedule = await Schedule.findByPk(id, {
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: Bus,
            as: 'bus',
            include: [{ model: BusType, as: 'busType' }]
          },
          {
            model: Driver,
            as: 'driver'
          },
          {
            model: SchedulePattern,
            as: 'pattern'
          }
        ]
      });
      
      if (!schedule) {
        return null;
      }
      
      return {
        id: schedule.id,
        busId: schedule.busId,
        routeId: schedule.routeId,
        driverId: schedule.driverId,
        departureTime: schedule.departureTime,
        actualDepartureTime: schedule.actualDepartureTime,
        actualArrivalTime: schedule.actualArrivalTime,
        price: schedule.price,
        status: schedule.status,
        isAutoGenerated: schedule.isAutoGenerated,
        patternId: schedule.patternId,
        createdAt: schedule.createdAt,
        bus: schedule.bus ? {
          id: schedule.bus.id,
          licensePlate: schedule.bus.licensePlate,
          seatCount: schedule.bus.seatCount,
          description: schedule.bus.description,
          busType: schedule.bus.busType ? {
            name: schedule.bus.busType.name
          } : null
        } : null,
        route: schedule.route ? {
          id: schedule.route.id,
          departureProvince: schedule.route.departureProvince ? schedule.route.departureProvince.name : null,
          arrivalProvince: schedule.route.arrivalProvince ? schedule.route.arrivalProvince.name : null,
          distanceKm: schedule.route.distanceKm,
          estimatedTime: schedule.route.estimatedTime
        } : null,
        driver: schedule.driver ? {
          id: schedule.driver.id,
          fullName: schedule.driver.fullName,
          phoneNumber: schedule.driver.phoneNumber,
          licenseNumber: schedule.driver.licenseNumber
        } : null,
        pattern: schedule.pattern ? {
          id: schedule.pattern.id,
          name: schedule.pattern.name
        } : null
      };
    } catch (error) {
      console.error('Error in getScheduleById:', error);
      throw new Error('Không thể lấy thông tin lịch trình');
    }
  },

  // Tạo lịch trình mới
  async createSchedule(scheduleData) {
    try {
      // Validate foreign keys
      await this.validateScheduleData(scheduleData);
      
      // Convert departureTime to proper Date object (keep original logic)
      let departureTime = scheduleData.departureTime;
      console.log('Original departureTime:', departureTime, typeof departureTime);
      
      if (typeof departureTime === 'string') {
        // Parse datetime as UTC directly (no timezone conversion)
        try {
          // Extract date and time parts
          const match = departureTime.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/);
          if (match) {
            const [, year, month, day, hour, minute, second] = match;
            // Create date in UTC timezone directly
            departureTime = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
          } else {
            // Parse as UTC directly
            departureTime = new Date(departureTime);
          }
        } catch (error) {
          console.error('Error parsing date:', error);
          throw new Error('Thời gian khởi hành không hợp lệ');
        }
      }
      
      console.log('Converted departureTime:', departureTime);
      
      // Validate date
      if (isNaN(departureTime.getTime())) {
        throw new Error('Thời gian khởi hành không hợp lệ');
      }
      
      // Format for SQL Server - YYYY-MM-DD HH:mm:ss
      const year = departureTime.getFullYear();
      const month = String(departureTime.getMonth() + 1).padStart(2, '0');
      const day = String(departureTime.getDate()).padStart(2, '0');
      const hours = String(departureTime.getHours()).padStart(2, '0');
      const minutes = String(departureTime.getMinutes()).padStart(2, '0');
      const seconds = String(departureTime.getSeconds()).padStart(2, '0');
      
      const sqlServerDateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      console.log('SQL Server formatted:', sqlServerDateTime);

      // Run validation checks AFTER datetime formatting to avoid SQL issues
      // Update scheduleData with converted departureTime for validation
      const validationData = { ...scheduleData, departureTime };

      // Validate that departure time is not in the past
      this.validateFutureTime(departureTime);

      // Validate time overlap (bus/driver conflicts)
      await this.validateTimeOverlap(validationData);

      // Validate location transition and travel time
      await this.validateLocationTransition(validationData);
      
      // Use raw SQL with proper datetime format (like updateSchedule)
      const { sql, poolPromise } = require('../config/db');
      const pool = await poolPromise;
      
      const result = await pool.request()
        .input('busId', sql.Int, scheduleData.busId)
        .input('routeId', sql.Int, scheduleData.routeId)
        .input('driverId', sql.Int, scheduleData.driverId)
        .input('departureTime', sql.DateTime, departureTime)
        .input('price', sql.Decimal(10, 2), scheduleData.price)
        .input('status', sql.VarChar(50), scheduleData.status || 'scheduled')
        .input('patternId', sql.Int, scheduleData.patternId || null)
        .input('isAutoGenerated', sql.Bit, scheduleData.patternId ? 1 : 0)
        .query(`
          INSERT INTO schedules (bus_id, route_id, driver_id, departure_time, price, status, pattern_id, is_auto_generated, created_at)
          OUTPUT INSERTED.id
          VALUES (@busId, @routeId, @driverId, @departureTime, @price, @status, @patternId, @isAutoGenerated, GETDATE())
        `);
      
      // Get the created schedule
      const scheduleId = result.recordset[0].id;
      const schedule = await Schedule.findByPk(scheduleId);
      
      // Create seats for the schedule
      await this.createSeatsForSchedule(scheduleId, scheduleData.busId);
      
      // Return the created schedule
      return await this.getScheduleById(scheduleId);
    } catch (error) {
      console.error('Error in createSchedule:', error);
      throw error;
    }
  },

  // Tạo nhiều lịch trình từ pattern
  async bulkCreateSchedules(bulkData) {
    try {
      // Get pattern information
      const pattern = await SchedulePattern.findByPk(bulkData.patternId, {
        include: [
          {
            model: Route,
            as: 'route',
            include: [
              { model: Province, as: 'departureProvince' },
              { model: Province, as: 'arrivalProvince' }
            ]
          },
          {
            model: BusType,
            as: 'busType'
          }
        ]
      });
      
      if (!pattern || !pattern.isActive) {
        throw new Error('Pattern không tồn tại hoặc không hoạt động');
      }
      
      // Parse departure times and days of week
      const departureTimes = JSON.parse(pattern.departureTimes);
      const daysOfWeek = pattern.daysOfWeek.split(',').map(d => parseInt(d.trim()));
      
      // Generate dates between start and end date
      const startDate = new Date(bulkData.startDate);
      const endDate = new Date(bulkData.endDate);
      const dates = [];
      
      for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
        const dayOfWeek = d.getDay() === 0 ? 7 : d.getDay(); // Convert Sunday from 0 to 7
        if (daysOfWeek.includes(dayOfWeek)) {
          dates.push(new Date(d));
        }
      }
      
      // Auto-assign bus and driver if not provided
      let assignedBusId = bulkData.busId;
      let assignedDriverId = bulkData.driverId;
      
      if (!assignedBusId) {
        // Find available bus for the route
        const bus = await Bus.findOne({
          where: { 
            isActive: true,
            busTypeId: pattern.busTypeId
          }
        });
        
        if (!bus) {
          throw new Error('Không tìm thấy xe bus phù hợp');
        }
        assignedBusId = bus.id;
      }
      
      if (!assignedDriverId) {
        // Find available driver
        const driver = await Driver.findOne({
          where: { isActive: true }
        });
        
        if (!driver) {
          throw new Error('Không tìm thấy tài xế phù hợp');
        }
        assignedDriverId = driver.id;
      }
      
      // Create schedules
      const createdSchedules = [];
      const failedSchedules = [];
      const price = bulkData.priceOverride || pattern.basePrice;
      
      for (const date of dates) {
        for (const time of departureTimes) {
          try {
                      const [hours, minutes] = time.split(':').map(Number);
          const departureTime = new Date(date);
          // Set hours in UTC directly
          departureTime.setHours(hours, minutes, 0, 0);
          // Use UTC time directly
          const utcDepartureTime = departureTime;
            
            const scheduleData = {
              busId: assignedBusId,
              routeId: pattern.routeId,
              driverId: assignedDriverId,
              departureTime: utcDepartureTime,
              price: price,
              status: 'scheduled',
              patternId: pattern.id
            };
            
            const schedule = await this.createSchedule(scheduleData);
            createdSchedules.push(schedule);
          } catch (error) {
            // Log failed schedule creation but continue with others
            const formattedDate = date.toLocaleDateString('vi-VN');
            failedSchedules.push({
              date: formattedDate,
              time: time,
              error: error.message
            });
            console.warn(`Failed to create schedule for ${formattedDate} ${time}:`, error.message);
          }
        }
      }
      
      return {
        created: createdSchedules.length,
        failed: failedSchedules.length,
        schedules: createdSchedules,
        failedSchedules: failedSchedules,
        summary: {
          patternName: pattern.name,
          dateRange: `${bulkData.startDate} - ${bulkData.endDate}`,
          totalDays: dates.length,
          schedulesPerDay: departureTimes.length,
          totalAttempted: dates.length * departureTimes.length
        }
      };
    } catch (error) {
      console.error('Error in bulkCreateSchedules:', error);
      throw error;
    }
  },

  // Cập nhật lịch trình
  async updateSchedule(id, updateData) {
    try {
      // Check if schedule exists
      const existingSchedule = await Schedule.findByPk(id);
      if (!existingSchedule) {
        return null;
      }

      // Check if schedule has bookings
      const { sql, poolPromise } = require('../config/db');
      const pool = await poolPromise;
      const bookingResult = await pool.request()
        .input('scheduleId', sql.Int, id)
        .query('SELECT COUNT(*) as count FROM bookings WHERE schedule_id = @scheduleId');
      
      const bookingCount = bookingResult.recordset[0].count;
      if (bookingCount > 0) {
        const error = new Error('Không thể sửa lịch trình đã có khách đặt');
        error.statusCode = 400;
        throw error;
      }
      
      // Validate foreign keys if provided
      if (updateData.busId || updateData.routeId || updateData.driverId) {
        await this.validateScheduleData(updateData);
      }
      
      // Process departureTime if provided
      if (updateData.departureTime) {
        // Parse the datetime similar to createSchedule
        let departureTime = updateData.departureTime;
        console.log('Original departureTime for update:', departureTime, typeof departureTime);
        
        if (typeof departureTime === 'string') {
          try {
            // Extract date and time parts
            const match = departureTime.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})/);
            if (match) {
              const [, year, month, day, hour, minute, second] = match;
                          // Create date in UTC timezone directly
            departureTime = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
            } else {
              // Try direct parsing
              departureTime = new Date(departureTime);
            }
          } catch (error) {
            console.error('Error parsing update date:', error);
            throw new Error('Thời gian khởi hành không hợp lệ');
          }
        }
        
        console.log('Converted departureTime for update:', departureTime);
        updateData.departureTime = departureTime;
        
        // Validate that departure time is not in the past
        this.validateFutureTime(departureTime);
      }

      // Create validation data combining existing schedule data with updates
      const validationData = {
        busId: updateData.busId || existingSchedule.busId,
        routeId: updateData.routeId || existingSchedule.routeId,
        driverId: updateData.driverId || existingSchedule.driverId,
        departureTime: updateData.departureTime || existingSchedule.departureTime
      };

      // Validate time overlap and location transition if any relevant fields are being updated
      if (updateData.busId || updateData.routeId || updateData.driverId || updateData.departureTime) {
        await this.validateTimeOverlap(validationData, id); // Exclude current schedule from conflict check
        await this.validateLocationTransition(validationData, id);
      }
      
      // Update schedule using raw SQL if departureTime is involved
      if (updateData.departureTime) {
        const { sql, poolPromise } = require('../config/db');
        const pool = await poolPromise;
        
        // Build dynamic update query
        const setParts = [];
        const request = pool.request();
        let paramIndex = 1;
        
        if (updateData.busId) {
          setParts.push(`bus_id = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Int, updateData.busId);
          paramIndex++;
        }
        
        if (updateData.routeId) {
          setParts.push(`route_id = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Int, updateData.routeId);
          paramIndex++;
        }
        
        if (updateData.driverId) {
          setParts.push(`driver_id = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Int, updateData.driverId);
          paramIndex++;
        }
        
        if (updateData.price) {
          setParts.push(`price = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.Decimal(10, 2), updateData.price);
          paramIndex++;
        }
        
        if (updateData.status) {
          setParts.push(`status = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.VarChar(50), updateData.status);
          paramIndex++;
        }
        
        if (updateData.departureTime) {
          setParts.push(`departure_time = @param${paramIndex}`);
          request.input(`param${paramIndex}`, sql.DateTime, updateData.departureTime);
          paramIndex++;
        }
        
        if (setParts.length > 0) {
          const query = `UPDATE schedules SET ${setParts.join(', ')} WHERE id = @scheduleId`;
          request.input('scheduleId', sql.Int, id);
          
          console.log('Raw SQL update query:', query);
          await request.query(query);
        }
      } else {
        // Use Sequelize for non-datetime updates
        await existingSchedule.update(updateData);
      }
      
      return await this.getScheduleById(id);
    } catch (error) {
      console.error('Error in updateSchedule:', error);
      throw error;
    }
  },

  // Xóa lịch trình
  async deleteSchedule(id) {
    try {
      // Check if schedule has bookings
      const bookingCount = await require('../models/BookingModel').count({
        where: { scheduleId: id }
      });
      
      if (bookingCount > 0) {
        throw new Error('Không thể xóa lịch trình có booking');
      }
      
      // Delete seats first
      await require('../models/SeatModel').destroy({
        where: { scheduleId: id }
      });
      
      // Delete schedule
      const result = await Schedule.destroy({
        where: { id: id }
      });
      
      return result > 0;
    } catch (error) {
      console.error('Error in deleteSchedule:', error);
      throw error;
    }
  },

  // Helper: Validate schedule data
  async validateScheduleData(scheduleData) {
    if (scheduleData.busId) {
      const bus = await Bus.findByPk(scheduleData.busId);
      if (!bus || !bus.isActive) {
        throw new Error('Xe bus không tồn tại hoặc không hoạt động');
      }
    }
    
    if (scheduleData.routeId) {
      const route = await Route.findByPk(scheduleData.routeId);
      if (!route || !route.isActive) {
        throw new Error('Tuyến đường không tồn tại hoặc không hoạt động');
      }
    }
    
    if (scheduleData.driverId) {
      const driver = await Driver.findByPk(scheduleData.driverId);
      if (!driver || !driver.isActive) {
        throw new Error('Tài xế không tồn tại hoặc không hoạt động');
      }
    }
  },

  // Helper: Create seats for schedule
  async createSeatsForSchedule(scheduleId, busId) {
    const bus = await Bus.findByPk(busId);
    if (!bus) {
      throw new Error('Xe bus không tồn tại');
    }
    
    const seatCount = bus.seatCount;
    const Seat = require('../models/SeatModel');
    
    // Create seats
    const seatData = [];
    for (let i = 1; i <= seatCount; i++) {
      const seatNumber = i.toString().padStart(2, '0');
      const floor = i <= 20 ? 'lower' : 'upper'; // Assume first 20 seats are lower floor
      
      seatData.push({
        scheduleId: scheduleId,
        seatNumber: seatNumber,
        status: 'available',
        floor: floor,
        isEnabled: true
      });
    }
    
    await Seat.bulkCreate(seatData);
  },

  // Helper: Calculate arrival time based on departure time and estimated time
  calculateArrivalTime(departureTime, estimatedTimeMinutes) {
    if (!departureTime || !estimatedTimeMinutes) {
      return null;
    }
    
    const departure = new Date(departureTime);
    const arrival = new Date(departure.getTime() + (estimatedTimeMinutes * 60 * 1000));
    return arrival;
  },

  // Helper: Validate time overlap between schedules
  async validateTimeOverlap(scheduleData, excludeScheduleId = null) {
    try {
      const { sql, poolPromise } = require('../config/db');
      const pool = await poolPromise;

      // Get route info to calculate arrival time
      const routeResult = await pool.request()
        .input('routeId', sql.Int, scheduleData.routeId)
        .query('SELECT estimated_time FROM routes WHERE id = @routeId AND is_active = 1');

      if (routeResult.recordset.length === 0) {
        throw new Error('Không thể xác định thời gian di chuyển của tuyến đường');
      }

      const estimatedTime = routeResult.recordset[0].estimated_time;
      if (!estimatedTime) {
        throw new Error('Tuyến đường chưa có thời gian di chuyển ước tính');
      }

      // Calculate arrival time for new schedule
      const newDepartureTime = new Date(scheduleData.departureTime);
      const newArrivalTime = this.calculateArrivalTime(newDepartureTime, estimatedTime);

      if (!newArrivalTime) {
        throw new Error('Không thể tính toán thời gian đến');
      }

      // Check for bus conflicts using raw SQL
      let busQuery = `
        SELECT s.departure_time, r.estimated_time 
        FROM schedules s 
        JOIN routes r ON s.route_id = r.id 
        WHERE s.bus_id = @busId 
        AND s.status IN ('scheduled', 'in_progress')
      `;
      
      if (excludeScheduleId) {
        busQuery += ' AND s.id != @excludeScheduleId';
      }

      const busRequest = pool.request()
        .input('busId', sql.Int, scheduleData.busId);
      
      if (excludeScheduleId) {
        busRequest.input('excludeScheduleId', sql.Int, excludeScheduleId);
      }

      const busConflicts = await busRequest.query(busQuery);

      // Check for driver conflicts using raw SQL
      let driverQuery = `
        SELECT s.departure_time, r.estimated_time 
        FROM schedules s 
        JOIN routes r ON s.route_id = r.id 
        WHERE s.driver_id = @driverId 
        AND s.status IN ('scheduled', 'in_progress')
      `;
      
      if (excludeScheduleId) {
        driverQuery += ' AND s.id != @excludeScheduleId';
      }

      const driverRequest = pool.request()
        .input('driverId', sql.Int, scheduleData.driverId);
      
      if (excludeScheduleId) {
        driverRequest.input('excludeScheduleId', sql.Int, excludeScheduleId);
      }

      const driverConflicts = await driverRequest.query(driverQuery);

      // Check bus time overlaps
      for (const conflict of busConflicts.recordset) {
        const conflictDeparture = new Date(conflict.departure_time);
        const conflictArrival = this.calculateArrivalTime(conflictDeparture, conflict.estimated_time);

        if (conflictArrival && this.isTimeOverlap(newDepartureTime, newArrivalTime, conflictDeparture, conflictArrival)) {
          throw new Error(`Xe bus đã có lịch trình từ ${conflictDeparture.toLocaleString('vi-VN')} đến ${conflictArrival.toLocaleString('vi-VN')}`);
        }
      }

      // Check driver time overlaps
      for (const conflict of driverConflicts.recordset) {
        const conflictDeparture = new Date(conflict.departure_time);
        const conflictArrival = this.calculateArrivalTime(conflictDeparture, conflict.estimated_time);

        if (conflictArrival && this.isTimeOverlap(newDepartureTime, newArrivalTime, conflictDeparture, conflictArrival)) {
          throw new Error(`Tài xế đã có lịch trình từ ${conflictDeparture.toLocaleString('vi-VN')} đến ${conflictArrival.toLocaleString('vi-VN')}`);
        }
      }

      return true;
    } catch (error) {
      throw error;
    }
  },

  // Helper: Check if two time ranges overlap
  isTimeOverlap(start1, end1, start2, end2) {
    return start1 < end2 && end1 > start2;
  },

  // Helper: Validate location transition and travel time
  async validateLocationTransition(scheduleData, excludeScheduleId = null) {
    try {
      const { sql, poolPromise } = require('../config/db');
      const pool = await poolPromise;

      // Get route info for the new schedule using raw SQL
      const newRouteResult = await pool.request()
        .input('routeId', sql.Int, scheduleData.routeId)
        .query(`
          SELECT r.id, r.departure_province_id, r.arrival_province_id, r.estimated_time,
                 dp.name as departure_province_name, ap.name as arrival_province_name
          FROM routes r
          JOIN provinces dp ON r.departure_province_id = dp.id
          JOIN provinces ap ON r.arrival_province_id = ap.id
          WHERE r.id = @routeId AND r.is_active = 1
        `);

      if (newRouteResult.recordset.length === 0) {
        throw new Error('Tuyến đường không tồn tại');
      }

      const newRoute = newRouteResult.recordset[0];
      const newDepartureTime = new Date(scheduleData.departureTime);

      // Find the most recent schedule for the same bus and driver before the new departure time using raw SQL
      let previousQuery = `
        SELECT TOP 2 s.id, s.bus_id, s.driver_id, s.departure_time,
               r.estimated_time, r.arrival_province_id
        FROM schedules s
        JOIN routes r ON s.route_id = r.id
        WHERE (s.bus_id = @busId OR s.driver_id = @driverId)
        AND s.departure_time < @departureTime
        AND s.status IN ('scheduled', 'in_progress')
      `;

      if (excludeScheduleId) {
        previousQuery += ' AND s.id != @excludeScheduleId';
      }

      previousQuery += ' ORDER BY s.departure_time DESC';

      const previousRequest = pool.request()
        .input('busId', sql.Int, scheduleData.busId)
        .input('driverId', sql.Int, scheduleData.driverId)
        .input('departureTime', sql.DateTime, newDepartureTime);

      if (excludeScheduleId) {
        previousRequest.input('excludeScheduleId', sql.Int, excludeScheduleId);
      }

      const previousResult = await previousRequest.query(previousQuery);
      const previousSchedules = previousResult.recordset;

      // Group by bus and driver
      const busPreviousSchedule = previousSchedules.find(s => s.bus_id === scheduleData.busId);
      const driverPreviousSchedule = previousSchedules.find(s => s.driver_id === scheduleData.driverId);

      // Validate bus location transition
      if (busPreviousSchedule) {
        await this.validateSingleLocationTransitionRaw(
          busPreviousSchedule,
          newRoute,
          newDepartureTime,
          'xe bus'
        );
      }

      // Validate driver location transition
      if (driverPreviousSchedule && driverPreviousSchedule.id !== busPreviousSchedule?.id) {
        await this.validateSingleLocationTransitionRaw(
          driverPreviousSchedule,
          newRoute,
          newDepartureTime,
          'tài xế'
        );
      }

      return true;
    } catch (error) {
      throw error;
    }
  },

  // Helper: Validate single location transition using raw SQL
  async validateSingleLocationTransitionRaw(previousSchedule, newRoute, newDepartureTime, resourceType) {
    const previousArrivalTime = this.calculateArrivalTime(
      new Date(previousSchedule.departure_time),
      previousSchedule.estimated_time
    );

    if (!previousArrivalTime) {
      return; // Skip validation if can't calculate previous arrival time
    }

    // Check if there's enough time between arrival and next departure (minimum 30 minutes)
    const minimumRestTime = 30 * 60 * 1000; // 30 minutes in milliseconds
    const timeBetween = newDepartureTime.getTime() - previousArrivalTime.getTime();

    if (timeBetween < minimumRestTime) {
      throw new Error(`${resourceType} cần nghỉ ít nhất 30 phút giữa các chuyến. Thời gian nghỉ hiện tại: ${Math.round(timeBetween / (60 * 1000))} phút`);
    }

    // Check location transition
    const previousArrivalProvinceId = previousSchedule.arrival_province_id;
    const newDepartureProvinceId = newRoute.departure_province_id;

    if (previousArrivalProvinceId !== newDepartureProvinceId) {
      // Different provinces - need to check travel time using raw SQL
      const { sql, poolPromise } = require('../config/db');
      const pool = await poolPromise;

      const transferRouteResult = await pool.request()
        .input('depProvinceId', sql.Int, previousArrivalProvinceId)
        .input('arrProvinceId', sql.Int, newDepartureProvinceId)
        .query(`
          SELECT estimated_time 
          FROM routes 
          WHERE departure_province_id = @depProvinceId 
          AND arrival_province_id = @arrProvinceId 
          AND is_active = 1
        `);

      let requiredTravelTime = 5 * 60 * 60 * 1000; // Default 5 hours
      if (transferRouteResult.recordset.length > 0 && transferRouteResult.recordset[0].estimated_time) {
        requiredTravelTime = transferRouteResult.recordset[0].estimated_time * 60 * 1000; // Convert minutes to milliseconds
      }

      if (timeBetween < requiredTravelTime) {
        const provinceResult = await pool.request()
          .input('prevProvinceId', sql.Int, previousArrivalProvinceId)
          .input('newProvinceId', sql.Int, newDepartureProvinceId)
          .query(`
            SELECT 
              (SELECT name FROM provinces WHERE id = @prevProvinceId) as prev_province_name,
              (SELECT name FROM provinces WHERE id = @newProvinceId) as new_province_name
          `);

        const provinceNames = provinceResult.recordset[0];
        
        throw new Error(
          `${resourceType} không thể di chuyển từ ${provinceNames.prev_province_name} đến ${provinceNames.new_province_name} trong ${Math.round(timeBetween / (60 * 60 * 1000))} giờ. ` +
          `Cần ít nhất ${Math.round(requiredTravelTime / (60 * 60 * 1000))} giờ`
        );
      }
    }
  },

  // Helper: Validate that departure time is not in the past
  validateFutureTime(departureTime) {
    const now = new Date();
    const departure = new Date(departureTime);
    
    if (departure <= now) {
      throw new Error('Không thể tạo chuyến đi trong quá khứ');
    }
    
    return true;
  }
};

module.exports = scheduleService; 